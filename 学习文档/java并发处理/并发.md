#  走入并行世界

##  基础操作

```
1. Thread
	join（） 
		作用： 让调用的线程先执行
		使用注意： 
				需在start 方法之后
				在 join 后边的线程才会受影响
```

## java 并行程序基础

```
1. ArrayList （vecotr）
	并发出现情况： 
		1.程序正常结束 ，数据也是正确
		2.程序抛出 ArrayIndexOutOfBoundsException 
		3.程序正常结束，但是数据不正确，对同一个地方，放入多次（简称  覆盖）
		
2. HashMap （ConcurrentHashMap）
	并发出现情况：
		1，程序正常结束，数据正确
		2. 程序正常结束，但结果不正确
		3. 程序永远无法结束  出现了死循环
	出现死循环的原因是：（jdk8 已改进）
		1.多个线程将hashMap的链表变成了一个环形的链表
				

3.查看程序中的线程情况
	使用 jstack pid
	
4. Integer  
	Integer i = Integer.valueOf(1);
	每次给 i 赋值 其实就是新创建了一个对象
```



## JDK 并发包

```
1. 重入锁
	1. 使用java.util.concurrent.locks.ReentrantLock
		1. 同一个线程可以多次调用 加锁 lock方法，但是解锁的时候，要和lock方法的个数相对应
	2. 公平锁
		1. 使用 sychronized 是不公平
		2. 重入锁允许我们对锁进行公平的设置
		特点：
			1. 系统维护一个有序队列 （实现成本高）
			2. 性能低下
	3.重要方法
		1.lock()：获得锁，如果锁已经被占用，则等待。
		2.lockInterruptibly():获得锁，但优先响应中断
		3.tryLock() : 尝试获得锁，如果成功，返回true，失败返回false。该方法不等待,立即返回
		4.tryLock(long time,TimeUnit unit) : 在给定时间内尝试获取锁
		5.unlock() :释放锁
	4.重入锁的三个要素
		1. 原子状态。原子状态使用CAS操作，来储存当前锁的状态，判断锁是否已经被别的线程持有了。
		2. 等待队列。所有没有请求到锁的线程，会进入等待队列进行等待，待有线程释放锁后，系统就能从等待队列中唤醒一个线程，继续工作
		3.阻塞原语park() 和 unpark(),用来挂起和恢复线程。没有得到锁的线程将会被挂起.

2.重入锁Condition
	1.方法含义
		1. await()方法会使当前的线程等待，同时释放当前锁，当其他线程中使用signal()方法或者signalAll()方法时，线程会重新获得锁并继续执行。或者当线程被中断时，也能挑出等待。这和Object.wait()方法相似.
		2.awaitUninterruptibly () 方法与 await()方法基本相同，但是他并不会等待过程中响应中断。
		3.singal()方法用户唤醒一个在等待中的线程。singalAll()方法会唤醒所有在等待中的线程。这和Object.notify()方法类似
```



## 并发级别

## 阻塞

​	1. 一个线程是阻塞的，那么在其他线程释放资源之前，当前线程无法继续执行。 

## 无饥饿

## 无障碍

## 无锁

## 无等待

